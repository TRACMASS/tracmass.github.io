<!doctype html>
<html lang="en">
    <head>    

        <title>Main modules - TRACMASS Theme</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="description" content="lorem-ipsum"/>
        <link rel="preconnect" href="https://fonts.gstatic.com">
        <link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="../../../assets/css/main.css">
        
        
        
    </head>
    <body class="palette-navy">
        
        <div id="page" class="site">
  <header id="masthead" class="site-header outer">
  <div class="inner">
    <div class="site-header-inside">
      <div class="site-branding">
        
        
        <p class="site-logo"><a href="../../../index.html"><img src="../../../images/headers_footer/fig_tracmass.png" alt="TRACMASS logo" /></a></p>
        
      </div><!-- .site-branding -->
      
      
      <nav id="main-navigation" class="site-navigation" aria-label="Main Navigation">
        <div class="site-nav-inside">
          <button id="menu-close" class="menu-toggle"><span class="screen-reader-text">Open Menu</span><span class="icon-close" aria-hidden="true"></span></button>
          <ul class="menu">
          
            
            
            <li class="menu-item">
              
              
<a href="../../../index.html"
  
  
  class="">
  
    Home
  
</a>

              
            </li>
          
            
            
            <li class="menu-item">
              
              
<a href="../../../docs.html"
  
  
  class="">
  
    Documentation
  
</a>

              
            </li>
          
            
            
            <li class="menu-item has-children">
              
              
<a href="../../../index.html"
  
  
  class="">
  
    Publications & Examples
  
</a>

              
                <button class="submenu-toggle"><span class="icon-angle-right" aria-hidden="true"></span><span class="screen-reader-text">Sub-menu</span></button>
                
                
<ul class="submenu">

  
  
  <li class="menu-item">
    
    
<a href="../../../publications.html"
  
  
  class="">
  
    Publications
  
</a>

  </li>

  
  
  <li class="menu-item">
    
    
<a href="../../../examples.html"
  
  
  class="">
  
    Example Gallery
  
</a>

  </li>

</ul>

              
            </li>
          
            
            
            <li class="menu-item">
              
              
<a href="../../../contact.html"
  
  
  class="">
  
    Contact & FAQ
  
</a>

              
            </li>
          
            
            
            <li class="menu-item">
              
              
<a href="../../../news.html"
  
  
  class="">
  
    News
  
</a>

              
            </li>
          
            
            
            <li class="menu-item menu-button">
              
              
<a href="https://github.com/TRACMASS/tracmass"
  
  
  class="button button-icon">
  
    
    
<svg class="icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
  
  <path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/>
  
</svg>

    <span class="screen-reader-text">GitHub</span>
  
</a>

              
            </li>
          
          </ul>
        </div><!-- .site-nav-inside -->
      </nav><!-- .site-navigation -->
      <button id="menu-open" class="menu-toggle"><span class="screen-reader-text">Close Menu</span><span class="icon-menu" aria-hidden="true"></span></button>
      
    </div><!-- .site-header-inside -->
  </div><!-- .inner -->
</header><!-- .site-header -->

  <main id="content" class="site-content">
    <div class="inner outer">
  <div class="docs-content">
    
    




<nav id="docs-nav" class="docs-nav">
  <div id="docs-nav-inside" class="docs-nav-inside sticky">
    <button id="docs-nav-toggle" class="docs-nav-toggle">Navigate Docs<span class="icon-angle-right" aria-hidden="true"></span></button>
    <div class="docs-nav-menu">
      <ul id="docs-menu" class="docs-menu">
        <li class="docs-menu-item">
          <a href="../../../docs.html">Welcome to TRACMASS' documentation</a>
        </li>
        
          
          
          
          
          
          
          
          <li class="docs-menu-item">
            <a href="../../about/index.html">About</a>
            
            
          </li>
        
          
          
          
          
          
          
          
          <li class="docs-menu-item has-children">
            <a href="../../configuration/index.html">Configuration</a>
            
            
              <button class="docs-submenu-toggle"><span class="screen-reader-text">Submenu</span><span class="icon-angle-right" aria-hidden="true"></span></button>
              
              


<ul class="docs-submenu">
  
    <li class="docs-menu-item">
      <a href="../../configuration/installation/index.html">Installation</a>
    </li>
  
    <li class="docs-menu-item">
      <a href="../../configuration/quick-start.html">How to set an experiment</a>
    </li>
  
</ul>

            
          </li>
        
          
          
          
          
          
          
          
          <li class="docs-menu-item has-children active">
            <a href="../index.html">TRACMASS Components</a>
            
            
              <button class="docs-submenu-toggle"><span class="screen-reader-text">Submenu</span><span class="icon-angle-right" aria-hidden="true"></span></button>
              
              


<ul class="docs-submenu">
  
    <li class="docs-menu-item">
      <a href="../main_program/index.html">Main program</a>
    </li>
  
    <li class="docs-menu-item current">
      <a href="index.html">Main modules</a>
    </li>
  
    <li class="docs-menu-item">
      <a href="../namelist/index.html"><p>Namelist</p></a>
    </li>
  
    <li class="docs-menu-item">
      <a href="../project/index.html"><p>The <em>Projects </em>folder</p></a>
    </li>
  
</ul>

            
          </li>
        
          
          
          
          
          
          
          
          <li class="docs-menu-item">
            <a href="../../output/index.html">TRACMASS output</a>
            
            
          </li>
        
          
          
          
          
          
          
          
          <li class="docs-menu-item has-children">
            <a href="../../tools/index.html">Tools</a>
            
            
              <button class="docs-submenu-toggle"><span class="screen-reader-text">Submenu</span><span class="icon-angle-right" aria-hidden="true"></span></button>
              
              


<ul class="docs-submenu">
  
    <li class="docs-menu-item">
      <a href="../../tools/insitu/index.html"><em>In situ</em>  postprocessing</a>
    </li>
  
    <li class="docs-menu-item">
      <a href="../../tools/pytraj/index.html">pyTRAJ</a>
    </li>
  
</ul>

            
          </li>
        
          
          
          
          
          
          
          
          <li class="docs-menu-item">
            <a href="../../references/index.html">References</a>
            
            
          </li>
        
      </ul><!-- .docs-menu -->
    </div><!-- .docs-nav-menu -->
  </div><!-- .docs-nav-inside -->
</nav><!-- .docs-nav -->

    <article class="post type-docs">
      <div class="post-inside">
        <header class="post-header">
          <h1 class="post-title line-left">Main modules</h1>
        </header><!-- .post-header -->
        <div class="post-content">
          <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default"></script>

<p>The present chapter will introduce all the modules in the <em>src</em> directory. The modules are organised in alphabetical order.</p>

<hr />
<h2 id="mod_calendarf90">mod_calendar.F90</h2>
<p>The module <strong>mod_calendar</strong> contains all the subroutines that initialise and update the calendar of the simulation. This module contains five subroutines: <strong>init_calendar</strong>, <strong>previous_calendar</strong>, <strong>update_calendar</strong>, <strong>end_calendar</strong> and <strong>tt_calendar</strong>.</p>

<ul>
  <li>
    <p>The subroutine <strong>init_calendar</strong> defines the starting date of the calendar as well as the time step of the simulation <strong>tseas</strong>.</p>
  </li>
  <li>
    <p><strong>update_calendar</strong> updated the calendar using the given time step and the initial date. The calendar is computed for both forward and backward simulations in time. Let us consider a simulation forward in time, where the start year (<strong>StartYear</strong>) is set to 2000 and the current year (<strong>currYear</strong>) is 2004. The variable <strong>iyear</strong> describes the number of simulation years. If <strong>loopYears</strong> is activated, after reaching the year set as <strong>loopEndYear</strong> (2010 in this case) the calendar is set back to the <strong>loopStartYear</strong> (2000). <strong>iyear</strong> is not altered by this correction.</p>
  </li>
</ul>
<p align="center">
  <img width="100%" src="../../../images/fig_calendar.png" />
</p>
<div class="important">
	&#9888; <strong>Warning:</strong> <br />
	Note than in backward simulations in time,  <strong>loopStartYear&gt;loopEndYear</strong>. The start year ( <strong>StartYear</strong>) is always larger or equal to the current year ( <strong>currYear</strong>) - unless  <strong>loopYears</strong> is activated.  If  <strong>loopYears</strong> is activated, the calendar is corrected in similar way to the forward simulations (see Figure above).
</div>

<ul>
  <li>
    <p><strong>end_calendar</strong> computes the final date of simulation defined by the time step <strong>intrun</strong>, while <strong>previous_calendar</strong> computes the date previous to the starting date. The latter is required when <strong>loopYears</strong> is activated.</p>
  </li>
  <li>
    <p><strong>tt_calendar</strong> uses the starting date as a reference and translates the time step <strong>tt</strong> into a date (year, month, day) and time (hour, minute, second).</p>
  </li>
</ul>

<hr />
<h2 id="mod_clockf90">mod_clock.F90</h2>
<p>The module <strong>mod_clock</strong> calculates the new time step referenced to the initial time step. This module contains one subroutine <strong>update_time</strong>.</p>
<p align="center">
  <img width="100%" src="../../../images/fig_time.png" />
</p>
<p>The subroutine updates <strong>tt</strong> and <strong>ts</strong> based on the value of <strong>ds</strong>. This is transform to a time step in seconds <strong>dt</strong> by multiplying <strong>ds</strong> with the volume <strong>dxyz</strong>. The subroutine chooses between the smallest of three different time steps:</p>

<p>1 - <strong>dtmin</strong> which is the time step between two time subcycles <script type="math/tex">t_{min} = \frac{\Delta t}{iter}</script> where <strong>iter</strong> is the number of subcycles.</p>

<p>2 - <strong>dtreg</strong> which is the time step to the next time subcycle.</p>

<p>3 - And the time step corresponding to the smallest wall crossing time computed with <strong>cross_time</strong>.</p>

<p>After updating the values of <strong>tt</strong> and <strong>ts</strong>, the new values of <strong>intrpb</strong> and <strong>intrpr</strong> are computed.</p>

<hr />
<h2 id="mod_diffusionf90">mod_diffusion.F90</h2>
<p>The module <strong>mod_diffusion</strong> adds a random displacement to a trajectory. Diffusion is activated by setting <strong>l_diffusion</strong> to TRUE. This module contains two subroutines: <strong>diffuse</strong> and <strong>displacement</strong>.</p>

<div class="important">
	&#9888; <strong>Warning:</strong> <br />
	By activating diffusion the calculation of stream functions is deactivated unless they are computed offline and  <strong>write_frec </strong> is set to one or two.
</div>

<ul>
  <li>
    <p>The subroutine <strong>diffuse</strong> works as follows: the new position of the trajectory calculated by <strong>update_traj</strong> is stored in a temporary position value <strong>tmpX, tmpY, tmpZ</strong>. The subroutine calls <strong>displacement</strong> to compute a random displacement. This displacement is add to <strong>tmpX, tmpY, tmpZ</strong>. The subroutine corrects the position if <strong>jperio</strong> or <strong>iperio</strong> are different from zero. The subroutine tries to find a suitable new position. If the new position is outside the domain, a new random displacement is calculated. The subroutine computes a maximum of 100k iterations, if no suitable positions are found by then, no displacement is added.</p>
  </li>
  <li>
    <p>The subroutine <strong>displacement</strong> computes a random displacement coordinates <strong>xd, yd, zd</strong> from the time step <strong>dt</strong>, and the values of the horizontal <strong>Ah</strong> and vertical <strong>Av</strong> diffusivity. The displacement are computed as follows:</p>
  </li>
</ul>

<p align="center">
  <img width="45%" src="../../../images/fig_diffusion.png" />
</p>

<script type="math/tex; mode=display">x_d = \sqrt{-4 A_h dt \log(1-q_1)} \cos(2\pi q_2) \\
   y_d = \sqrt{-4 A_h dt \log(1-q_1)} \sin(2\pi q_2) \\
   z_d = \sqrt{-4 A_v dt \log(1-q_3)} \cos(2\pi q_4) \\</script>

<p>where <script type="math/tex">q_n</script> represent random numbers defined between zero and one.</p>

<hr />
<h2 id="mod_divergencef90">mod_divergence.F90</h2>
<p>The module <strong>mod_divergence</strong> computes divergence/convergence of all the tracers defined in the namelist. This module will be activated if both <strong>l_tracer</strong> and <strong>l_divergence</strong> are <strong>TRUE</strong>.</p>

<ul>
  <li>
    <p>The subroutine <strong>init_divergence</strong> initialises and allocates the variable <strong>tracerdiv</strong>. This variable is a two dimensional variable in space (x-y coordinates), and is computed for all the tracers (<strong>numtracers</strong>) and number of killing zones.</p>

    <table>
      <thead>
        <tr>
          <th>Variable name</th>
          <th>Dimensions</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>tracerdiv</td>
          <td>imt x jmt x 20 x numtracers</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>The tracer divergence is computed in the subroutine <strong>compute_divergence</strong>. Only trajectories that have reached a killing zone are considered to compute the divergences. The divergence field is updated when a trajectory crosses a gridwall. The value of the tracer at the wall times the mass/volum flux of the trajectory is added to the gridbox where the trajectory is entering. The same value is substracted to the gridbox that the trajectory exited.</p>
  </li>
</ul>

<p align="center">
  <img width="60%" src="../../../images/fig_divergence.png" />
</p>

<div class="note">
  <strong>Note:</strong> <br />
	The <strong>tracerdiv</strong> is divided by the area of the gridbox and multiple the constant described by <strong>divconst</strong>. A different constant value can be assigned per tracer.
</div>

<hr />
<h2 id="mod_errorf90">mod_error.F90</h2>
<p>The module <strong>mod_error</strong> check for possible errors in the simulation. If any error is found a diagnostic file with a summary of the error is created. This module contains two subroutines and two private function: <strong>errorCheck</strong>, <strong>write_error</strong>, <strong>errorType</strong>, and <strong>reverse</strong>.</p>

<ul>
  <li>
    <p><strong>errorCheck</strong> check for a possible error defined by <strong>teststr</strong>. The possible errors are listed below:</p>

    <table>
      <tbody>
        <tr>
          <td><strong>teststr</strong></td>
          <td><strong>errCode</strong></td>
          <td>Description</td>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><em>infLoopError</em></td>
          <td>1</td>
          <td>Trajectory trapped in an <strong>infinite loop</strong></td>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><em>dxyzError</em></td>
          <td>2</td>
          <td>The volume of the gridbox is <strong>zero</strong> or <strong>negative</strong></td>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><em>boundError</em></td>
          <td>3</td>
          <td>Trajectory leaving the <strong>domain</strong></td>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><em>landError</em></td>
          <td>4</td>
          <td>Trajectory hits a <strong>land</strong> point</td>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><em>coordboxError</em></td>
          <td>5/6/7</td>
          <td>Trajectory placed in the <strong>wrong</strong> box</td>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><em>dsCrossError</em></td>
          <td>8</td>
          <td>No <strong>available pathways</strong> for the trajectory</td>
        </tr>
      </tbody>
    </table>

    <div class="note">
      <strong>Note:</strong> <br />
       A <strong>infinite loop</strong> is defined when a trajectory is iterated more than 30000 times since last time it crossed a wall or started a time subcycle.
  </div>
  </li>
  <li>
    <p>If an error is found in a trajectory, the last position and time step will be stored in a <em>_err.csv</em> file. The module <strong>write_error</strong> besides writing the number of the trajectory <strong>ntrac</strong>, the last position <strong>x1, y1, z1</strong>, the volume/mass transport <strong>subvol</strong> and the time step; it also gives a short description of the error.</p>

    <div class="note">
      <strong>Note:</strong> <br />
       The positions are given referenced to the original dataset reference system.
  </div>
  </li>
  <li>
    <p><strong>errorType</strong> is a private function that gives a short description of the error given by <strong>errorCode</strong>. This output is used by <strong>write_error</strong>.</p>
  </li>
  <li>
    <p><strong>reverse</strong> updates the indexes if the original data’s grid does not correspond to the TRACMASS grid set up.</p>
  </li>
</ul>

<hr />
<h2 id="mod_getfilef90">mod_getfile.F90</h2>
<p>The module <strong>mod_getfile</strong> consists on five functions: <strong>filledFileName</strong> which updates the dateprefix according to the calendar, <strong>getScalarNC</strong> to extract scalars, <strong>get1DfieldNC</strong> to extract 1D data fields, <strong>get2DfieldNC</strong> to extract 2D data fields, and <strong>get3DfieldNC</strong> to extract 3D data fields.</p>

<ul>
  <li>
    <p>The function <strong>filledFileName</strong> has four arguments: <em>filedPattern</em> a character string that contains the dateprefix, and <em>inyear</em>, <em>inmon</em> and <em>inday</em> representing the year, month and day of the calendar. The function will find the string YYYYMMDD and replace it with the corresponding year, month or/and day.</p>
  </li>
  <li>
    <p>The function <strong>getScalarNC</strong> has two arguments: <em>fieldFile</em> the path to the netCDF file, and <em>varName</em> name of the variable to be extracted.</p>
  </li>
  <li>
    <p>The function <strong>get1DfieldNC</strong> has four arguments: <em>fieldFile</em> the path to the netCDF file, <em>varName</em> name of the variable to be extracted, <em>start1D</em> a 4D array that describes the starting indexes, and <em>count1D</em> a 4D array that describes how many indexes are read.</p>
  </li>
  <li>
    <p>The function <strong>get2DfieldNC</strong> has five arguments: <em>fieldFile</em> the path to the netCDF file, <em>varName</em> name of the variable to be extracted, <em>start2D</em> a 4D array that describes the starting indexes, and <em>count2D</em> a 4D array that describes how many indexes are read. The last index <em>stcase</em> describes the order in which the data is stored in the netCDF file:</p>

    <p>– <em>‘st’</em>:  [x, y, time] <br />
   – <em>‘st_r’</em>: [y, x, time]</p>
  </li>
  <li>
    <p>The function <strong>get3DfieldNC</strong> has five arguments: <em>fieldFile</em> the path to the netCDF file, <em>varName</em> name of the variable to be extracted, <em>start3D</em> a 4D array that describes the starting indexes, <em>count3D</em> a 4D array that describes how many indexes are read, and <em>stcase</em> describes the order data is stored in the netCDF file:</p>

    <p>– <em>‘ts’</em>:  [time, x, y, z] <br />
   – <em>‘st’</em>:  [x, y, z, time] <br />
   – <em>‘ts_r’</em>: [time, z, y, x] <br />
   – <em>‘st_r’</em>: [z, y, x, time]</p>
  </li>
</ul>

<div class="note">
		<strong>Note:</strong> <br />
		 If the original data is reduced to a subdomain, both functions will only extract data in the selected subdomain. For the case where the subdomain crosses the zonal limit of the original domain, the function will read separately the two subdomains and then join them into a unique subdomain (blue domain).
	<p align="center">
  <img width="60%" src="../../../images/fig_netcdf.png" />
</p>
</div>

<hr />
<h2 id="mod_initf90">mod_init.F90</h2>
<p>The module <strong>mod_init</strong> consists of two subroutines: <strong>init_namelist</strong> that reads the namelist, and <strong>init_alloc</strong> that allocates all the allocatable arrays. More information about the namelist can be found in the <em>Namelist</em> chapter.</p>

<p>It contains an internal subroutine <strong>reverse</strong> to adapt the meridional indexes to the TRACMASS reference system.</p>

<hr />
<h2 id="mod_loopf90">mod_loop.F90</h2>
<p>The module <strong>mod_loop</strong> is the core module of TRACMASS. This module contains the big loop that updates the calendar, the clock and the position of the trajectories.</p>

<p align="center">
  <img width="100%" src="../../../images/fig_loop.png" />
</p>

<p>This is how the module works:</p>

<p>1 - First the fields are updated according to the value of <strong>ints</strong>.</p>

<p>2 - Then, if the time step corresponds to a seeding time, the subrotuine <strong>seed</strong> is called.</p>

<p>3 - Then the loop checks all the possible trajectories given by <strong>ntrac</strong>. If the trajectory is not activated the module while skip it.</p>

<p>4 - If a trajectory is activated it will be iterated several times where its position will be updated (<strong>update_traj</strong>).</p>

<p>5 - If the trajectory exceedes the limit time <strong>timax</strong>, it will be deactivated.</p>

<p>6 - After each iteration the calendar is updated.</p>

<div class="note">
		<strong>Note:</strong> <br />
		 If all the trajectories are deactivated the simulation will be stopped even if the corresponding time step is not the final one set by <strong>intrun</strong>.
</div>

<hr />
<h2 id="mod_pos_tstepf90--mod_pos_tanalyticalf90">mod_pos_tstep.F90 / mod_pos_tanalytical.F90</h2>
<p>Both modules <strong>mod_pos_tstep.F90</strong> and <strong>mod_pos_tanalytical.F90</strong> calculate the new position of a trajectory and the time it will take to cross a wall in the gridbox. However, each of these modules computes the crossing time using different schemes. Currently two different schemes are available: regular time step scheme (default case) and the time analytical scheme (which can be activated in the project Makefile). Each of these modules contains three public subroutines: <strong>cross_time</strong>, <strong>calc_pos</strong>, and <strong>update_traj</strong>. Only the subroutine <strong>update_traj</strong> is common in both schemes.</p>

<ul>
  <li>
    <p>The subroutine <strong>update_traj</strong> updates the position of the trajectory after a time step given by <strong>ds</strong> and computes the new values for <strong>x1</strong>, <strong>y1</strong>, and <strong>z1</strong>. It also updates the value of <strong>boxface</strong> which is zero if the trajectory remains inside the box or is assigned with a value between <strong>1-6</strong> if it crosses one of the walls. The subroutines check if any of the crossing values given by <strong>cross_time</strong> corresponds to the value of <strong>ds</strong> to determine the new position.</p>

    <table>
      <tbody>
        <tr>
          <td><strong>ds</strong></td>
          <td><strong>ib</strong>  / <strong>jb</strong>  / <strong>kb</strong></td>
          <td>Crossing wall  (<strong>boxface</strong>)</td>
        </tr>
        <tr>
          <td>dse</td>
          <td><strong>ia + 1</strong>  / ja / ka</td>
          <td>Eastern (<strong>1</strong>)</td>
        </tr>
        <tr>
          <td>dsw</td>
          <td><strong>ia - 1</strong>  / ja / ka</td>
          <td>Western (<strong>2</strong>)</td>
        </tr>
        <tr>
          <td>dsn</td>
          <td>ia /  <strong>ja + 1</strong> / ka</td>
          <td>Northern (<strong>3</strong>)</td>
        </tr>
        <tr>
          <td>dss</td>
          <td>ia /  <strong>ja - 1</strong>  / ka</td>
          <td>Southern (<strong>4</strong>)</td>
        </tr>
        <tr>
          <td>dsu</td>
          <td>ia / ja / <strong>ka + 1</strong></td>
          <td>Upper wall (<strong>5</strong>)</td>
        </tr>
        <tr>
          <td>dsd</td>
          <td>ia / ja / <strong>ka - 1</strong></td>
          <td>Lower wall (<strong>6</strong>)</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>
<p align="center">
  <img width="80%" src="../../../images/fig_boxface.png" />
</p>

<p>If <strong>ds</strong> is smaller than any of the crossing times and equal to the time stepping, or if the trajectory is inside a convergence zone where all the crossing times are <strong>UNDEF</strong>. The trajectory remains inside the box.</p>

<div class="note">
		<strong>Note :</strong> <br />
By default trajectories can reach the last vertical level <strong>km</strong> and will be flagged with the exit flag <strong>one</strong>. However, by activating <strong>l_nosurface</strong> trajectories are prevented from reaching the surface. Instead, they are placed back in the middle of the last grid box (<strong>ka = km</strong>).
<br />
<br />
<strong>Note:</strong> <br />
If stream functions are computed online (<em>l_offline</em> is false), this subroutine will transfer the required information to compute geographical streamfunctions.
<br />
<br />
<strong>Important:</strong> <br />
The north fold (<strong>jperio</strong>) is an important feature for original grids that are not based on latitude longitude such as the ORCA grids. The current version includes two possible corrections to the north fold: no correction (0), and  correction for ORCA grids (1).
</div>

<hr />
<h3 id="regular-time-step-scheme">Regular time step scheme</h3>
<ul>
  <li>The subroutine <strong>cross_time</strong> computes the time it will take to cross any of the faces determined by the variable <strong>ijk</strong>. The possible values of <strong>ijk</strong> are (1) for the east/west faces, (2) for the north/south faces, and (3) for the up/down faces. For simplicity, let us consider the case of <strong>ijk</strong> =1 with an eastward zonal flow <strong>uflux</strong>.</li>
</ul>

<p align="center">
  <img width="60%" src="../../../images/fig_boxpos.png" />
</p>

<p style="margin-left: 10px;">This is how the module works:</p>

<ol>
<li style="padding-bottom:1em;">- First, the interpolated values of the zonal flow <strong>uflux</strong> in the east wall (<strong>uu</strong>) and in the west wall (<strong>um</strong>) are computed. A linear interpolation is used to obtained the values for <strong>uu</strong> and <strong>um</strong>:
 $$
     U_i(t) = \frac{(t-t_0) \ U_i(t_1) + (t_1-t) \ U_i(t_0)}{t_1-t_0} \quad \text{where} \quad t_0 \le t \le t_1.
 $$

  In this case \( t_0 \) and \( t_1 \) represent the <strong>n</strong> and <strong>n+1</strong> time step.
</li>
<li style="padding-bottom:1em">- If <strong>uu</strong> is positive the subroutine computes the crossing time through the eastern wall  \(t_E\)(<strong>sp</strong>).
<ul style="list-style-type:none;">
<li style="padding-bottom:1em;">- If  <strong>uu</strong> = <strong> um</strong> , the time it will take to the trajectory to cross the east wall is:

$$
			 t_{E} = \frac{x_E-x}{U_i(t)}.
$$
</li>
	<li style="padding-bottom:1em;">- If <strong>uu</strong> \(\neq\) <strong>um</strong>, the velocity field inside the box is linearly interpolated:

$$
			 U(x) = (x-x_W)(U(x_E)-U(x_W)) + U(x_W) \quad \text{where} \quad x_W \le x \le x_E,
$$

where <strong>iam</strong> represents the index for the western wall (\(x_W\)) and <strong>ia</strong> represents the eastern wall (\(x_E\)). If \(U(x)&gt;0\) at the starting position of the particle, the time to reach the eastern wall is given by:

$$
			 t_{E} = \frac{1}{U(x_W)-U(x_E)}\log\left(\frac{U(x)}{U_E} \right)
$$
</li>
<li style="padding-bottom:1em;">-If none of the above conditions is fulfilled the subroutine returns the value <strong>UNDEF</strong> for <strong>sp</strong>.
</li>
</ul>
</li>
<li>- Following a similar procedure, the subroutine computes the crossing time through the western wall (<strong>sn</strong>).
</li>
</ol>
<div class="note">
		<strong>Note:</strong> <br />
		 The equations used to compute the crossing time considers a different spatial interpolation of \(U(x)\) for <strong>sn</strong>. The crossing time through the western wall is given by the following equation \(t_{W} = \frac{1}{U(x_W)-U(x_E)}\log\left(\frac{U(x)}{U_W} \right)\).
</div>

<ul>
  <li>The subroutine <strong>calc_pos</strong> computes the new position of the trajectory after time <strong>ds</strong> in the direction given by <strong>ijk</strong>. This subroutine works in the following way (let us consider the same case as in the previous example for <strong>cross_time</strong>):</li>
</ul>

<ol>
<li style="padding-bottom:1em;">- First, the interpolated values of the zonal flow <strong>uflux</strong> in the east wall (<strong>uu</strong>) and in the west wall (<strong>um</strong>) are computed. A linear interpolation is used to obtained the values for <strong>uu</strong> and <strong>um</strong>.
</li>
<li style="padding-bottom:1em;">- If  <strong>uu</strong> = <strong>um</strong>, the new position of the trajectory is given by:
$$
     x_1 = x_0 + U(x_E)ds
$$
</li>
<li>- On the other hand, if <strong>uu</strong> \(\neq\) <strong>um</strong> the new position is:
$$
     x_1 = \left(x_0 - x_W + \frac{U(x_W)}{U(x_E)-U(x_W)} \right) e^{(U(x_E)-U(x_W))ds} + x_W - \frac{U(x_W)}{U(x_E)-U(x_W)}$$.
</li>
</ol>

<div class="important">
	&#9888; <strong>Warning:</strong> <br />
	If the trajectory is placed at \(U(x)=0\) in a divergent field, <strong>calc_pos</strong> is not able to determine the new position (unstable equilibrium).
</div>
<hr />
<h3 id="time-analytical-scheme">Time analytical scheme</h3>

<ul>
  <li>The subroutine <strong>cross_time</strong> computes the time it will take to cross any of the faces determined by the variable <strong>ijk</strong>. The possible values of <strong>ijk</strong> are (1) for the east/west faces, (2) for the north/south faces, and (3) for the up/down faces. For simplicity, let us consider the case of <strong>ijk</strong> =1.</li>
</ul>

<p style="margin-left: 10px;">This is how the module works:</p>

<ol>
<li style="padding-bottom:1em;">- First, the volume/mass flux values are computed at the nearest gridwalls (\(x_E\) and \(x_W\)) and at the nearest time steps (\(t_0\) and \(t_1\)):

<p align="center">
  <img width="60%" src="../../../images/fig_timeanalytical.png" />
</p>

$$
    U(x_E,t_0) = \textbf{uu} \quad U(x_W,t_0) = \textbf{um}\\
    U(x_E,t_1) = \textbf{vv}  \quad U(x_W,t_1) = \textbf{vm}
$$

 In this case \( t_0 \) and \( t_1 \) represent the <strong>n</strong> and <strong>n+1</strong> time step.
</li>

<li style="padding-bottom:1em;">- Then, the coefficient \(\alpha^{*}\) is computed:
$$
    \alpha^{*} = -(\textbf{vv}-\textbf{vm}-\textbf{uu}+\textbf{um}).
$$
Depending on the value of \(\alpha^{*}\) three different subroutines are called to calculate the crossing time:
<strong>apos</strong> (\(\alpha^{*}&gt;0\)), <strong>aneg</strong> (\(\alpha^{*}&lt;0\)), and <strong>azer</strong> (\(\alpha^{*}=0\)).

</li>

<li style="padding-bottom:1em;">-The subroutines <strong>apos</strong>, <strong>aneg</strong>, and <strong>azer</strong> compute the crossing time as well as identify the crossing wall. This is done by finding the roots of the equation \( r(s_w) - r_w = 0\) numerically; where \(r \equiv x/\Delta x\) represents the position indexes, \(s_w\) is the volume normalised time, and  \(r_w\) is one of the exit walls.

<p align="center">
  <img width="100%" src="../../../images/fig_cases.png" />
</p>

The subroutines try first to calculate the crossing time through the eastern wall (northern wall for <strong>ijk=2</strong>, and uppwe wall for <strong>ijk=3</strong>). Four different cases may arise:

<ol>
<li style="padding-bottom:1em;">- Fluxes at <strong>ia</strong> are positive between the time steps <strong>n</strong> and <strong>n+1</strong>
</li>

<li style="padding-bottom:1em;">- Fluxes at <strong>ia</strong> change from positive to negative at some time between the time steps <strong>n</strong> and <strong>n+1</strong>
</li>

<li style="padding-bottom:1em;">- Fluxes at <strong>ia</strong> change from negative to positive at some time between the time steps <strong>n</strong> and <strong>n+1</strong>
</li>

<li style="padding-bottom:1em;">- Fluxes at <strong>ia</strong> are negative between the time steps <strong>n</strong> and <strong>n+1</strong>
</li>
</ol>

<p>
These cases are illustrated in the figure above. Except for the fourth cases, the other three cases may have a crossing time across the eastern wall. If the crossing time exceeds the maximum time given by \( t_1 \), the output will be <strong>UNDEF</strong>.
</p>
<p>
If there is no crossing through the eastern wall or if there is a possibility that the time to cross the western wall is smaller, the subroutine reconsiders again the four conditions described before.
</p>
<p>
The roots to solve the equation are computed using a bisection method that guarantees a convergence towards the root.
</p>

<div class="note">
		<strong>Note :</strong> <br />
	For a more detailed description of the time analytical method check <a href="https://gmd.copernicus.org/articles/10/1733/2017/">Döös et al. 2017</a>
</div>

</li>
<li style="padding-bottom:1em;">- Finally, depending on the crossing wall index the value of <strong>dse</strong> and <strong>dsw</strong> are updated.
<table>
  <tr>
    <th> \(r_w\) cross wall index</th>
    <th>dse/dsn/dsu</th>
    <th>dsw/dss/dsd</th>
  </tr>
  <tr>
    <td><strong>ia</strong></td>
    <td>\(s_w-s_0\) </td>
    <td>UNDEF</td>
  </tr>
  <tr>
    <td><strong>iam</strong></td>
    <td>UNDEF</td>
    <td>\(s_w-s_0\)</td>
  </tr>
  <tr>
    <td>-99</td>
    <td>UNDEF</td>
    <td>UNDEF</td>
  </tr>
</table>
where \(s_w\) and \(s_0\) are the crossing time and the initial time (volume normalised), respectively.
</li>
</ol>

<ul>
  <li>The subroutine <strong>calc_pos</strong> computes the new position of the trajectory after time <strong>ds</strong> in the direction given by <strong>ijk</strong>. This subroutine works in the following way (let us consider the same case as in the previous example for <strong>cross_time</strong>):</li>
</ul>

<ol>
<li style="padding-bottom:1em;">- First, the volume/mass flux values are computed at the nearest gridwalls (\(x_E\) and \(x_W\)) and at the nearest time steps (\(t_0\) and \(t_1\)).
</li>

<li style="padding-bottom:1em;">- Then, the coefficients \(\alpha\)(<strong>alfa</strong>), \(\beta\)(<strong>beta</strong>), \( \gamma\)(<strong>gamma</strong>), \(\delta \)(<strong>delta</strong>) are computed:
$$\begin{eqnarray*}
    \alpha &amp;=&amp; - \frac{1}{\Delta s}(\textbf{vv}-\textbf{vm}-\textbf{uu}+\textbf{um}),\\
    \beta &amp;=&amp; (\textbf{um}-\textbf{uu}) - \alpha\cdot\textbf{sm},\\
    \gamma &amp;=&amp; - \frac{1}{\Delta s}(\textbf{vm}-\textbf{um}) - \alpha\cdot\textbf{iam}, \\
    \delta &amp;=&amp; -\textbf{um} + \textbf{iam}\cdot(\textbf{uu}-\textbf{um}) - \gamma\cdot\textbf{sm}.
\end{eqnarray*} $$
where \(\Delta s\) (<strong>dstep</strong>)is the volume normalised time step, and <strong>sm</strong> corresponds to \(s^{n-1}\).
</li>
<li style="padding-bottom:1em;">- Depending on the value \(\alpha\) different trajectories paths are available:

<ul>
<li style="padding-bottom:1em;"> \(\alpha\) &gt; 0: For this case, we define the time-like variable \(\xi = (\beta + \alpha\cdot s)/\sqrt{2\alpha}\) and \(r_0 = r(s0)\), where \(s_0\) is the initial time. The new position of the trajectory is given by:
$$
r(s) = \left(r_0 + \frac{\gamma}{\alpha}\right) e^{\xi_0^2-\xi^2} - \frac{\gamma}{\alpha} + \frac{\beta\gamma - \alpha\delta}{\alpha}\sqrt{\frac{2}{\alpha}}[D(\xi)-e^{\xi_0^2-\xi^2}D(\xi_0)]
$$

where \(D(\xi)\) is the Dawson's integral.
</li>

<li style="padding-bottom:1em;"> \(\alpha\) &lt; 0: For this case, we define the time-like variable \(\zeta = (\beta + \alpha\cdot s)/\sqrt{-2\alpha}\) and \(r_0 = r(s0)\), where \(s_0\) is the initial time. The new position of the trajectory is given by:
$$
r(s) = \left(r_0 + \frac{\gamma}{\alpha}\right) e^{\zeta^2-\zeta_0^2} - \frac{\gamma}{\alpha} - \frac{\beta\gamma - \alpha\delta}{\alpha}\sqrt{\frac{\pi}{-2\alpha}}e^{\zeta^2}[\textrm{erf}(\zeta)-\textrm{erf}(\zeta_0)]
$$

where \(\textrm{erf}(\zeta)\) is the error function.
</li>

<li> \(\alpha\) = 0, which would normally not occur in realistic GCM:
$$
r(s) = \left(r_0 + \frac{\delta}{\beta}\right) e^{-\beta(s-s_0)} - \frac{\delta}{\beta} + \frac{\gamma}{\beta^2}[1 - \beta s + (\beta s_0 -1)e^{-\beta(s-s_0)}]
$$
</li>

</ul>
</li>
</ol>

<div class="note">
		<strong>Note :</strong> <br />
	The Dawson's integral are computed following the subroutine describe <a href="https://aip.scitation.org/doi/pdf/10.1063/1.4822832">here</a> (function <strong>daw</strong> in the module). The error function and the complementary error function are computed following this <a href="http://www.phys.uri.edu/nigh/NumRec/bookfpdf/f6">subroutines</a> (functions <strong>fun_erf</strong> and <strong>fun_erfc</strong> in the module) instead of using the intrisic ERF and ERFC functions.
</div>

<hr />
<h2 id="mod_postprocessf90">mod_postprocess.F90</h2>
<p>The module <strong>mod_postprocess</strong> reads the output files, computes offline streamfunctions, tracer divergence map, and a more detailed summary of the TRACMASS run.</p>

<ul>
  <li>
    <p>The subroutine <strong>postprocessing</strong> reads the output files and stores the require information to compute a summary or offline streamfunctions/divergence calculation. The following information is read: the initial number of trajectories and total transport (from <em>_ini.csv</em>), the number of trajectories that left the domain or exceeded the time limit and the total tranport (from <em>_out.csv</em>), and the position indexes and the tracer values (from <em>_run.csv</em> if offline streamfunctions or divergences are computed).</p>
  </li>
  <li>
    <p><strong>init_alloc_postprocessing</strong> allocates and initialises the required arrays to compute offline streamfunctions and/or to compute tracer divergence.</p>
  </li>
  <li>
    <p><strong>print_summary</strong> prints a short summary of the total number of trajectories that are initialised and the ones that left the domain (organised by the different killing zones). It also prints a summary of the transports. This subroutine is only called if the main program is run with the <em>summary</em> argument on (see chapters <em>Configuration</em> and <em>Main program</em>).</p>
  </li>
</ul>

<hr />
<h2 id="mod_printf90">mod_print.F90</h2>
<p>The module <strong>mod_print</strong> is responsible for printing the basic information about the run which includes a short summary of the model configuration, the number of trajectories run and a final summary of the number trajectories that are still running, have been deactivated or have errors.</p>

<hr />
<h2 id="mod_seedf90">mod_seed.F90</h2>
<p>The module <strong>mod_seed</strong> defines all the variables and arrays neccesary for the seeding of particles. This modules contains two public subroutines (<strong>init_seed</strong> and <strong>seed</strong>) and three private subroutines (<strong>split_grid</strong> , <strong>read_mask</strong>, and <strong>reverse</strong>)</p>

<p>The subroutine <strong>init_seed</strong> defines the grid points and the time steps where the particles are going to be initialised, the wall of the grid where they are going to be placed (<strong>isec</strong>), and their direction (<strong>idir</strong>). There are three options for <strong>isec</strong>: (1) on the east wall of the grid cell, (2) on the north wall of the grid cell, and (3) on the top wall of the grid cell. idir selects the initial direction of the trajectories eastward/northward/upward (<strong>idir = 1</strong>) or westward/southward/downward (<strong>idir = -1</strong>).</p>

<p align="center">
  <img width="60%" src="../../../images/fig_isec.png" />
</p>

<div class="note">
		<strong>Note :</strong> <br />
	If the simulation is backward in time (<strong>nff = -1</strong>), idir represents the last direction of the trajectory to follow. For example, let us consider a eastward flow field. A simulation with <strong>nff = -1</strong> and <strong>idir = 1</strong> will follow trajectories back in time that initially are moving eastward.
</div>

<p>The initial seeding location, time, and direction can be defined directly in the namelist or read from a file. This is control by <strong>seedType</strong> and <strong>seedTime</strong>.</p>

<ul>
  <li><strong>seedType</strong>: (1) the seeding location is defined by the grid points within the volume described by <strong>(ist2-ist1+1)x(jst2-jst1+1)x(kst2-kst1+1)</strong>, all these trajectories will shared the <strong>idir</strong> and <strong>isec</strong> defined in the namelist, (2) the seeding location and the direction is read from an external file <strong>seedDir/seedfile</strong>.</li>
</ul>

<div class="note">
		<strong>Important :</strong> <br />
	The mask file only will be read if <strong>seedType</strong> is set to one. The <strong>mask</strong> array is two dimensional and has the dimensions <em>imt x jmt</em>. If a mask file is provided (<strong>maskFile</strong>), only the values where <strong>mask=1</strong> (marked in orange in the figure) will be selected for seeding. <br />
	<p align="center">
  <img width="80%" src="../../../images/fig_mask.png" />
</p>
</div>

<p>The reading of the mask file is done by the internal subroutine <strong>read_mask</strong>. The indexes in the mask file are in the original file reference system.</p>

<ul>
  <li><strong>seedTime</strong>: (1) the seeding happens in the time interval defined between <strong>tst2</strong> and <strong>tst1</strong>, or (2) it is read from a external file <strong>seedDir/timeFile</strong>.</li>
</ul>

<p>The <strong>seed</strong> subroutine populates the <strong>trajectory</strong> array that contains the position of the trajectories as well as their corresponding volume/mass transport. This module works this way:</p>

<p>1 - The subroutine checks if the current time <strong>ntime</strong> corresponds to a seeding time.</p>

<p>2 - The corresponding flux is chosen according to the value of <strong>isec</strong>. If the direction does not correspond to the value of <strong>idir</strong> the trajectory is not activated.</p>

<p>3 - <strong>num</strong>, the number of trajectories per grid point, is defined. There are different options based on <strong>nqua</strong>: (1) the number of trajectories is defined by <strong>partQuant</strong>, or (2) the particles transport a specific volume/mass transport defined by <strong>partQuant</strong>, the number of particles in the grid is then defined dividing the total volume/mass transport by <strong>partQuant</strong>.</p>

<p align="center">
  <img width="80%" src="../../../images/fig_nqua.png" />
</p>

<p>4 - The grid is split in equal parts using the private subroutine <strong>split_grid</strong>. If <strong>num</strong> is a square number the grid cell is divided in equal squares, if <strong>num</strong> is a prime number the grid is split in equal rectangles along one axis (see figure below). For other cases, <strong>split_grid</strong> will divide the square in equal rectangles with similar side lengths.</p>

<p align="center">
  <img width="80%" src="../../../images/fig_num.png" />
</p>

<p>5 - The specific volume/mass transport of a trajectory <strong>subvol</strong> is computed from <strong>num</strong>.</p>

<p>6 - The trajectories are placed in the middle of each of the rectangles. This initial position is given by <strong>x1, y1, z1</strong>.</p>

<div class="note">
		<strong>Important :</strong> <br />
	<strong>x1, y1, z1</strong> are computed using the gridbox as a reference.
</div>

<p>7 - If TRACMASS is rerun or run to compute streamfunctions, only the trajectories that exit through a kill zone will be activated.
Besides, if <strong>l_tracers</strong> is true, the trajectories outside the tracer limits <strong>tracer0min</strong> and <strong>tracer0max</strong> will be deactivated.</p>

<p>8 - The position of the trajectory in the gridbox reference system, the trajectory number <strong>ntrac</strong>, the corresponding position index and the mass/volume transported by it is stored in the array <strong>trajectories</strong>.</p>

<p>The private subroutine <strong>reverse</strong> adjust the seeding indexes to the TRACMASS reference system.</p>

<hr />
<h2 id="mod_streamf90">mod_stream.F90</h2>
<p>The module <strong>mod_stream.F90</strong> is responsible for computing volume/mass fluxes and compute different stream functions. This module contains four subroutines <strong>compute_stream</strong>, <strong>init_stream</strong>, <strong>update_fluxes</strong> (online computation of streamfunctions) and <strong>compute_stream</strong> (offline computation of streamfunctions).</p>

<ul>
  <li>
    <p>The subroutine <strong>init_stream</strong> initialises and allocates all the fluxes (<em>fluxes_</em>) and streamfunction (<em>psi_</em>) arrays.</p>

    <table>
      <tbody>
        <tr>
          <td><em>Flux type</em></td>
          <td><strong>l_offline</strong> = TRUE</td>
          <td><strong>l_offline</strong> = FALSE</td>
        </tr>
        <tr>
          <td>Barotropic (x-y)</td>
          <td>(imt, jmt, 21)</td>
          <td>(imt, jmt, ntractot)</td>
        </tr>
        <tr>
          <td>Zonal (x-z)</td>
          <td>(imt,  km, 21)</td>
          <td>(imt,  km, ntractot)</td>
        </tr>
        <tr>
          <td>Meridional (y-z)</td>
          <td>(jmt,  km, 21)</td>
          <td>(jmt,  km, ntractot)</td>
        </tr>
        <tr>
          <td>Longitude-tracer (x-r)</td>
          <td>(imt, mr, 21, numtracers)</td>
          <td>(imt, mr, ntractot, numtracers)</td>
        </tr>
        <tr>
          <td>Latitude-tracer (y-r)</td>
          <td>(jmt, mr, 21, numtracers)</td>
          <td>(jmt, mr, ntractot, numtracers)</td>
        </tr>
        <tr>
          <td>Tracer-tracer (r-r)</td>
          <td>( mr, mr, 21, numtracers)</td>
          <td>( mr, mr, ntractot, numtracers)</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<div class="note">
		<strong>Note :</strong> <br />
	The last three cases are only computed if <em>l_tracer</em> is TRUE, where <strong>mr</strong> is the tracer space resolution (501 by default) and <strong>numtracers</strong> is the number of tracers.
</div>

<ul>
<li>
* If streamfunctions are computed online (<em>l_offline</em> is false), the subrotuine <strong>update_fluxes</strong> is responsible to update the fluxes and filter them according to the trajectory number. This subroutine has six arguments: <strong>index1, index2</strong> represent the indexes of the two coordinates of the streamfunction, <strong>dir</strong> is the direction of the trajectory (in the stream function coordinate reference system), <strong>psicase</strong> indicates the type of streamfunction that is computed (<em>'xy'</em>: barotropic, <em>'xz'</em>: zonal stream function, <em>'yz'</em>: meridional stream function, <em>'xr'</em>: longitude-tracer stream function, <em>'yr'</em>: latitude-tracer stream function, and <em>'rr'</em>: tracer-tracer stream function). The fifth argument is optional (<strong>indt1</strong>) and it is used whenever a <em>'yr'</em> streamfunction is used to represent the different tracer choice.

$$
    F(\textbf{index1,index2}[, \textbf{indt1}]) = F(\textbf{index1,index2}[, \textbf{indt1}]) + dir \cdot \textbf{subvol}
$$

 If <strong>psicase</strong> is <em>'rr'</em>, <strong>index1, index2</strong> are linked to the present and past time step of the first tracer, and <strong>indt1, indt2</strong> are the present and past time step of the second tracer. The computation of the fluxes in this case is more generalised:

$$
   F(\textbf{indm1,indm2}) = \textbf{subvol}
$$

 where \( \textbf{indm1}=[index1,index2) \) and  \( \textbf{indm2}=indt1 + slope \cdot(\textbf{indm1}-index1) \). The slope is given by \( (indt2-indt1)/(index2-index1) \).

</li>
</ul>

<p align="center">
  <img width="60%" src="../../../images/fig_fluxes.png" />
</p>

<ul>
  <li>
    <p>If streamfunctions are computed offline (<em>l_offline</em> is true), the subrotuine <strong>compute_fluxes</strong> is responsible to update the fluxes and filter them according to the killing zones. If <em>write_frec</em> is 3 (stored everytime it crosses a wall) or 4 (save everytime), the fluxes are computed when the stored index corresponds to a zonal wall (barotropic) or to a meridional wall (meridional or latitude-tracer). The tracer-tracer fluxes are computed as in the online case. For other <em>write_frec</em> all the fluxes are computed using the method to compute the tracer-tracer fluxes (see the online case).</p>
  </li>
  <li>
    <p>The subroutine <strong>compute_stream</strong> integrates the fluxes computed by <strong>update_fluxes</strong> or <strong>compute_fluxes</strong> to compute the stream functions. In the case of online calculation of stream function, the subroutine filters only the <em>ntracs</em> that exited through the killing zones. The integration direction is defined by <strong>dirpsi</strong>.</p>
  </li>
</ul>

<script type="math/tex; mode=display">\Psi(\textbf{index1, index2} [  , \textbf{indt}])  = \sum^{ \textbf{index2} }_{index=0} -F(\textbf{index1}, index [, \textbf{indt}] ) \quad \text{(dirpsi = 1)} \\

   \Psi(\textbf{index1, index2} [, \textbf{indt}]) = \sum_{index=\textbf{index2}} F(\textbf{index1}, index[, \textbf{indt}])  \quad \text{(dirpsi = -1)}.</script>

<div class="note">
		<strong>Note :</strong> <br />
This is an example of how a stream function is computed. Consider two trajectories (A) with the same volume/mass transport. The computed fluxes are shown in (B) where blue represents positive fluxes and orange negative fluxes. Notice that the region where both trajectories cross the same wall the resulting flux is zero as they cancel each other. The resulting stream function (C) is computed integrating in a downward direction.

	<p align="center">
  <img width="80%" src="../../../images/fig_stream.png" />
</p>

</div>

<hr />
<h2 id="mod_subdomainf90">mod_subdomain.F90</h2>
<p>The module <strong>mod_subdomain.F90</strong> is responsible for defining a subdomain and updating the indexes according to the new domain. Defining a subdomain is useful to run TRACMASS with high resolution data especially if the area of study does not cover the whole original domain. Two types of subdomain can be declared: a regular box (<strong>imindom</strong> &lt; <strong>imaxdom</strong>) and a split box (<strong>imaxdom</strong> &lt; <strong>imindom</strong>).</p>

<p align="center">
  <img width="100%" src="../../../images/fig_subdomain_1.png" />
</p>

<div class="note">
		<strong>Note :</strong> <br />
The subdomain is only defined in the longitude-latitude space.
</div>

<p>It consists of two subroutines <strong>init_subdomain</strong> and <strong>update_subindex</strong>:</p>

<ul>
  <li>
    <p>The subroutine <strong>init_subdomain</strong> defines the size of the new subdomain. If a subdomain is chosen (<strong>l_subdomain</strong> is true) the new size of the domain is defined as:</p>

    <table>
      <tbody>
        <tr>
          <td><em>Subdomain type</em></td>
          <td><em>zonal dimension</em> (<strong>imt</strong>)</td>
          <td><em>meridional dimension</em> (<strong>jmt</strong>)</td>
        </tr>
        <tr>
          <td>Regular box</td>
          <td><strong>imaxdom</strong> - <strong>imindom</strong> + 1</td>
          <td><strong>jmaxdom</strong> - <strong>jmindom</strong> + 1</td>
        </tr>
        <tr>
          <td>Split box</td>
          <td><strong>imtdom</strong> + <strong>imaxdom</strong>  - <strong>imindom</strong> + 1</td>
          <td><strong>jmaxdom</strong> - <strong>jmindom</strong> + 1</td>
        </tr>
      </tbody>
    </table>

    <p>Besides, once the subdomain is declared a kill zone is imposed around the boundaries of the subdomain. To avoid problems with the possible kill zones defined by the user in <strong>kill_zones.F90</strong> the subdomain kill zones are declared for the indexes 7,8,9 and 10.</p>
  </li>
</ul>

<p align="center">
  <img width="70%" src="../../../images/fig_subdomain_2.png" />
</p>

<ul>
  <li>The subroutine <strong>update_subindex</strong> updates the subindexes before trajectories are seeded. The indexes are updated using <strong>imindom</strong> and <strong>jmindom</strong> as referenced. There is an special case for the <em>Split box</em> case.</li>
</ul>

<table style="width: 100%;">
        <tbody>
            <tr>
                <td style="width: 33.3333%;"><em>Subdomain type</em><br /></td>
                <td style="width: 33.3333%;"><em>zonal index</em> (<strong>ji</strong>)<br /></td>
                <td style="width: 33.3333%;"><em>meridional index</em> (<strong>jj</strong>)<br /></td>
            </tr>
            <tr>
                <td style="width: 33.3333%;">Regular box<br /></td>
                <td style="width: 33.3333%;"><strong>ji</strong> - <strong>imindom</strong> + 1<br /></td>
                <td style="width: 33.3333%;"><strong>jj</strong> - <strong>jmindom</strong> + 1<br /></td>
            </tr>
            <tr>
                <td rowspan="2" style="width: 33.2149%;">Split box<br /></td>
                <td style="width: 33.3333%;"><strong>ji</strong> - <strong>imindom</strong> + 1 &nbsp; &nbsp;(if <strong>imindom</strong> &lt;= <strong>ji</strong> )<br /></td>
                <td rowspan="2" style="width: 33.2149%;"><strong>jj</strong> - <strong>jmindom</strong> + 1<br /></td>
            </tr>
            <tr>
                <td style="width: 33.3333%;"><strong>ji</strong> - <strong>imtdom</strong> - <strong>imindom</strong> + 1 (otherwise)<br /></td>
            </tr>
        </tbody>
    </table>

<hr />
<h2 id="mod_swapf90">mod_swap.F90</h2>
<p>The module <strong>mod_swap.F90</strong> is responsible for updating the time indexes for those variables that are time dependent (for more information check the description of <strong>read_field.F90</strong>) and reversing the fluxes if the trajectories are run backward in time.</p>

<hr />
<h2 id="mod_tracersf90">mod_tracers.F90</h2>
<p>If TRACMASS is run with tracers (<strong>l_tracers</strong> is true), the module <strong>mod_tracers.F90</strong> contains all the subroutines needed to initialise, allocate, compute and update tracers.</p>

<ul>
  <li><strong>init_tracer</strong> initialise the <strong>tracers</strong> array from the information provided in the namelist. This information consists of a short description of the tracer (<strong>name</strong>), <strong>units</strong>, whether the tracer is read from an input file ( <strong>action</strong> ==’read’) or computed in TRACMASS ( <strong>action</strong> =’compute’). If the tracer is read, the name of the variable in the input file is given by <strong>varname</strong> and the number of <strong>dimension</strong>-s.</li>
</ul>

<div class="note">
		<strong>Important :</strong> <br />
	To compute stream functions it is important to define the lower (<strong>minimum</strong>) and the upper (<strong>maximum</strong>) limit of the tracer coordinate.
</div>

<ul>
  <li>If <strong>action</strong> is compute, the subroutine <strong>compute_tracer</strong> will calculate the tracer from other tracers read from input files.</li>
</ul>

<table>
  <tbody>
    <tr>
      <td><em>tracername</em></td>
      <td>Description</td>
      <td>External function</td>
      <td>Argument 1</td>
      <td>Argument 2</td>
    </tr>
    <tr>
      <td>sigma0</td>
      <td>sigma-0 density</td>
      <td><strong>thermo_dens0</strong></td>
      <td>Temperature</td>
      <td>Salinity</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><strong>update_tracers</strong> updates the value of the tracer in the new position (computed by <strong>update_traj</strong>). The tracers are updated using the nearest point approach where trajectory stores the value of the tracer in the nearest T point. If the trajectory crosses a grid wall the tracer value is the mean value between the two nearest T points. A time interpolation is computed before the spatial interpolation.</li>
</ul>

<p align="center">
  <img width="70%" src="../../../images/fig_subdomain_2.png" />
</p>

<ul>
  <li>
    <p>The private subroutine <strong>tracers_default</strong> assigns default values to the <strong>tracers</strong> array for the most common tracers. The tracers included in this subroutine are:</p>

    <table>
      <tbody>
        <tr>
          <td><strong>name</strong></td>
          <td><strong>unit</strong></td>
          <td><strong>minimum</strong></td>
          <td><strong>maximum</strong></td>
          <td><strong>action</strong></td>
          <td><strong>varname</strong></td>
          <td>Descripition</td>
        </tr>
        <tr>
          <td>To</td>
          <td>degC</td>
          <td>-3</td>
          <td>33</td>
          <td>read</td>
          <td>T</td>
          <td>Temperature (Ocean)</td>
        </tr>
        <tr>
          <td>Ta</td>
          <td>K</td>
          <td>173</td>
          <td>223</td>
          <td>read</td>
          <td>T</td>
          <td>Temperature (Atmosphere)</td>
        </tr>
        <tr>
          <td>Tp</td>
          <td>K</td>
          <td>173</td>
          <td>223</td>
          <td>read</td>
          <td>Tp</td>
          <td>Potential temperature</td>
        </tr>
        <tr>
          <td>S</td>
          <td>g kg-1</td>
          <td>32</td>
          <td>38</td>
          <td>read</td>
          <td>S</td>
          <td>Salinity</td>
        </tr>
        <tr>
          <td>q</td>
          <td>g kg-1</td>
          <td>0</td>
          <td>25</td>
          <td>read</td>
          <td>q</td>
          <td>Specific humidity</td>
        </tr>
        <tr>
          <td>sigma0</td>
          <td>kg m-3</td>
          <td>19</td>
          <td>29</td>
          <td>compute</td>
          <td> </td>
          <td>Sea water density (sigma0)</td>
        </tr>
        <tr>
          <td>sigma0_K</td>
          <td>kg m-3</td>
          <td>19</td>
          <td>29</td>
          <td>compute</td>
          <td> </td>
          <td>——–//—— (T in K)</td>
        </tr>
        <tr>
          <td>p</td>
          <td>hPa</td>
          <td>0</td>
          <td>1100</td>
          <td>compute</td>
          <td> </td>
          <td>Atmospheric pressure</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>The function <strong>tracerbin</strong> translates the tracervalue to an index in the tracer space,</p>
  </li>
</ul>

<script type="math/tex; mode=display">tracerbin = \frac{tracervalue - min(tracervalue)}{\Delta tracervalue}</script>

<hr />
<h2 id="mod_varsf90">mod_vars.F90</h2>
<p><strong>mod_vars.F90</strong> is a collection of different modules that define the required variables for the different components of TRACMASS. This file contains 10 modules:</p>

<ul>
  <li>
    <p><strong>mod_precdef</strong>: defines the precisions of the REAL variables.</p>
  </li>
  <li>
    <p><strong>mod_log</strong>: defines the verbose variables.</p>
  </li>
  <li>
    <p><strong>mod_param</strong>: the general parameters of TRACMASS are defined here.</p>
  </li>
  <li>
    <p><strong>mod_seedvars</strong>: the variables used in <strong>mod_seed</strong> are defined here.</p>
  </li>
  <li>
    <p><strong>mod_trajdef</strong>: the derived TYPE <strong>trajectory</strong> is defined in this module.</p>
  </li>
  <li>
    <p><strong>mod_loopvars</strong>: the variables used in <strong>mod_loop</strong> are defined here.</p>
  </li>
  <li>
    <p><strong>mod_traj</strong>: the variables to describe a trajectory are defined here.</p>
  </li>
  <li>
    <p><strong>mod_grid</strong>: the grid variables, and the boundary conditions are defined here.</p>
  </li>
  <li>
    <p><strong>mod_time</strong>: defines the variables used by <strong>mod_calendar</strong> and <strong>mod_clock</strong>.</p>
  </li>
  <li>
    <p><strong>mod_domain</strong>: defines the variables to describe the limits of the domain where the trajectory is activated.</p>
  </li>
  <li>
    <p><strong>mod_vel</strong>: the volume/mass fluxes both horizontal and vertical are defined here.</p>
  </li>
  <li>
    <p><strong>mod_trajdef</strong>: the derived TYPE <strong>tracers</strong> is defined in this module.</p>
  </li>
  <li>
    <p><strong>mod_tracervars</strong>: the variables to describe tracers are defined here.</p>
  </li>
  <li>
    <p><strong>mod_psi</strong>: defines the variables to describe the stream functions.</p>
  </li>
  <li>
    <p><strong>mod_postprocessvars</strong>: the variables part of the postprocessing are defined here.</p>
  </li>
  <li>
    <p><strong>mod_activevars</strong>: the variables part of the lagrangian diffusion scheme are defined here.</p>
  </li>
  <li>
    <p><strong>mod_divvars</strong>: the variables part of the tracer divergence calculation are defined here.</p>
  </li>
</ul>

<hr />
<h2 id="mod_vertvelf90">mod_vertvel.F90</h2>
<p>The module <strong>mod_vertvel</strong> computes the vertical volume/mass fluxes. If TRACMASS is setup for two dimensional fields, or the vertical velocity is part of the dataset this module is not activated.</p>

<p>This module contains a single subroutine <strong>vertvel</strong> that computes the vertical flux using the following equation:</p>

<script type="math/tex; mode=display">W^n_{i,j,k,n} = W^n_{i,j,k-1} - ( U^n_{i,j,k,n}-U^n_{i-1,j,k} + V^n_{i,j,k} - V^n_{i,j-1,k}) - area(i,j)\frac{\Delta z^{n+1}_{i,j,k}-\Delta z^{n-1}_{i,j,k}}{2\Delta t}</script>

<p>This equation is integrated from the bottom (ocean) or the TOA (atmosphere) to the level <strong>ka</strong>.</p>

<hr />
<h2 id="mod_writef90">mod_write.F90</h2>
<p>The module <strong>mod_write</strong> creates the outfiles where the information of the trajectories is stored. This module is responsible for writing four important files: <em>_ini.csv</em> where the initial positions are stored, <em>_out.csv</em> where the final positions are stored, <em>_run.csv</em> where the new positions of the trajectory are stored, and  <em>_rerun.csv</em> where the trajectory number and the flag corresponding to the kill zone is stored. The output data is stored in the directory given by <strong>outDataDir</strong> and the output files start with the prefix given by <strong>outDataFile</strong>. If those values are not specified, the current working directory becomes the default output directory.</p>

<div class="important"> &#9888; <strong>Warning:</strong> <br />  If a particle is not terminated it will not be stored in the <em>_rerun.csv</em> file. </div>

<p align="center">
  <img width="80%" src="../../../images/fig_write.png" />
</p>

<p>The initial and the final information of the trajectories are always stored. However, the frequency at which data is stored in the <em>_run.csv</em> is controlled by <strong>write_frec</strong>: (1) only at GCM time steps, (2) only at GCM and subcycle time steps, (3) only when a trajectory crosses a wall, (4) all time steps, and (5) no data stored.
The time format of the output files can also be adjusted with <strong>timeformat</strong>: (0) <strong>tt</strong> is stored, (1) <strong>ts</strong> is stored, (2) the time is saved in YYYY-MM-DD HH format.</p>

<div class="note">
		<strong>Note :</strong> <br />
	The format in which the output is written is controlled by <strong>write_form</strong>. The default value is <strong>zero</strong> which writes the output with two decimals. By setting <strong>write_form</strong> to <strong>one</strong> the output is written with five decimals.
<br />
<br />
<strong>Important:</strong> <br />
 If TRACMASS is run with the stream function flag this module also writes the resulting stream functions in the files: <em>_psixy.csv</em> for the barotropic case, <em>_psiyz.csv</em> for the meridional case, <em>_psiyr.csv</em> for the latitude-tracer case, and <em>_psirr.csv</em> for the tracer-tracer stream functions. Besides, the subroutine <strong>read_rerun</strong> will be used to read the trajectories that will be run and the flag corresponding to the kill zones.
<br />
<br />
<strong>Important:</strong> <br />
 If TRACMASS is run with tracer divergence computation, this module also writes the results in the file: <em>_div.csv</em>.
</div>

          
          
          
            
            
            
            
            
          
        </div><!-- .post-content -->
      </div><!-- .post-inside -->
    </article><!-- .post -->
    <nav id="page-nav" class="page-nav">
      <div id="page-nav-inside" class="page-nav-inside sticky">
        <h2 class="page-nav-title">Jump to Section</h2>
        <div id="page-nav-link-container"></div>
      </div><!-- .page-nav-inside -->
    </nav><!-- .page-nav -->
  </div><!-- .docs-content -->
</div><!-- .inner-->

  </main><!-- .site-content -->
  <footer id="colophon" class="site-footer outer">
  <div class="inner">
    <div class="site-footer-inside">
      <p class="site-info">
        
        
        <span class="copyright">&copy; Stackbit. All rights reserved. This Jamstack site was originally created by Stackbit and modified by the TRACMASS team.</span>
        
        
      </p><!-- .site-info -->
      
      
      <div class="social-links">
        
      </div><!-- .social-links -->
      
    </div><!-- .site-footer-inside -->
  </div><!-- .inner -->
</footer><!-- .site-footer -->

</div><!-- .site -->

        <!-- Scripts -->
        <script src="../../../assets/js/plugins.js"></script>
        <script src="../../../assets/js/main.js"></script>
        <script src="../../../assets/js/page-load.js"></script>
    </body> 
</html>
